from core import Unit,USi,powUnit,mulUnit,divUnit,floatToFraction,siTo,unitInner,UStr
from math import `^`,floor,sqrt,cbrt,pow,`mod`,ceil,hypot,round,
  trunc,gcd,lcm,floorDiv,floorMod,euclDiv,euclMod,ceilDiv

func `+`*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.} =Unit[T,U](T(l)+T(r.siTo(U.unitInner)))
func `-`*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.} =Unit[T,U](T(l)-T(r.siTo(U.unitInner)))
func `*`*[T;U1,U2:UStr](l:Unit[T,U1],r:Unit[T,U2]):Unit[T,mulUnit(U1,U2)]{.inline.}=Unit[T,mulUnit(U1,U2)](T(l)*T(r))
func `/`*[T;U1,U2:UStr](l:Unit[T,U1],r:Unit[T,U2]):Unit[T,divUnit(U1,U2)]{.inline.}=Unit[T,divUnit(U1,U2)](T(l)/T(r))
func `div`*[T;U1,U2:UStr](l:Unit[T,U1],r:Unit[T,U2]):Unit[T,divUnit(U1,U2)]{.inline.}=Unit[T,divUnit(U1,U2)](T(l) div T(r))
func `*`*[T;U:UStr](l:Unit[T,U],r:T):Unit[T,U]{.inline.}=Unit[T,U](T(l)*r)
func `/`*[T;U:UStr](l:Unit[T,U],r:T):Unit[T,U]{.inline.}=Unit[T,U](T(l)/r)
func `div`*[T;U:UStr](l:Unit[T,U],r:T):Unit[T,U]{.inline.}=Unit[T,U](T(l) div r)
func `*`*[T;U:UStr](r:T,l:Unit[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l)*r)
func `div`*[T;U:UStr](r:T,l:Unit[T,U]):Unit[T,powUnit(U,(-1,1))]{.inline.}=Unit[T,powUnit(U,(-1,1))](r div T(l))
func `^`*[T;U:UStr](l:Unit[T,U],n:static[(int,int)]):Unit[T,powUnit(U,n)]{.inline.}=Unit[T,powUnit(U,n)]T(T(l) ^ (n[0]/n[1]))
func `^`*[T;U:UStr](l:Unit[T,U],n:static[int]):Unit[T,powUnit(U,(n,1))]{.inline.}=Unit[T,powUnit(U,(n,1))]T(T(l) ^ n.float)
func `^`*[T;U:UStr](l:Unit[T,U],n:static[float]):Unit[T,powUnit(U,floatToFraction(n))]{.inline.}=Unit[T,powUnit(U,floatToFraction(n))]T(T(l) ^ n)
func sqrt*[T;U:UStr](x:Unit[T,U]):Unit[T,powUnit(U,(1,2))]{.inline.}=Unit[T,powUnit(U,(1,2))]T(sqrt T(x))
func cbrt*[T;U:UStr](x:Unit[T,U]):Unit[T,powUnit(U,(1,3))]{.inline.}=Unit[T,powUnit(U,(1,3))]T(cbrt T(x))
func `mod`*[T;U:UStr](l:Unit[T,U],n:T):Unit[T,U]{.inline.}=Unit[T,U]T(T(l) mod n)
func `mod`*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l) mod T(r.siTo(U.unitInner)))
func abs*[T;U:UStr](l:Unit[T,U]):Unit[T,U]{.inline.}=Unit[T,U](abs T(l))
func floor*[T;U:UStr](l:Unit[T,U]):Unit[T,U]{.inline.}=Unit[T,U](floor T(l))
func ceil*[T;U:UStr](l:Unit[T,U]):Unit[T,U]{.inline.}=Unit[T,U](ceil T(l))
func round*[T;U:UStr](l:Unit[T,U]):Unit[T,U]{.inline.}=Unit[T,U](round T(l))
func trunc*[T;U:UStr](l:Unit[T,U]):Unit[T,U]{.inline.}=Unit[T,U](trunc T(l))
func max*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).max T(r.siTo(U.unitInner)))
func min*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).min T(r.siTo(U.unitInner)))
func gcd*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).gcd T(r.siTo(U.unitInner)))
func lcm*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).lcm T(r.siTo(U.unitInner)))
func clamp*[T;U:UStr](a:Unit[T,U],b:USi[T,U],c:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](clamp(T(a),T(b.siTo(U.unitInner)),T(c.siTo(U.unitInner))))
func `==`*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):bool{.inline.}=T(l)==T(r.siTo(U.unitInner))
func `<`*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):bool{.inline.}=T(l)<T(r.siTo(U.unitInner))
func `<=`*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):bool{.inline.}=T(l)<=T(r.siTo(U.unitInner))
func hypot*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).hypot T(r.siTo(U.unitInner)))
func floorDiv*[T;U1,U2:UStr](l:Unit[T,U1],r:Unit[T,U2]):Unit[T,divUnit(U1,U2)]{.inline.}=Unit[T,divUnit(U1,U2)](T(l).floorDiv T(r))
func ceilDiv*[T;U1,U2:UStr](l:Unit[T,U1],r:Unit[T,U2]):Unit[T,divUnit(U1,U2)]{.inline.}=Unit[T,divUnit(U1,U2)](T(l).ceilDiv T(r))
func euclDiv*[T;U1,U2:UStr](l:Unit[T,U1],r:Unit[T,U2]):Unit[T,divUnit(U1,U2)]{.inline.}=Unit[T,divUnit(U1,U2)](T(l).euclDiv T(r))
func floorMod*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).floorMod T(r.siTo(U.unitInner)))
func euclMod*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):Unit[T,U]{.inline.}=Unit[T,U](T(l).euclMod T(r.siTo(U.unitInner)))
func divmod*[T;U:UStr](l:Unit[T,U],r:USi[T,U]):(T,Unit[T,U]){.inline.}=(T(euclDiv(l,r).siTo""),euclMod(l,r))
